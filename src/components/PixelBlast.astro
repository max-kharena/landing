---
interface Props {
  color?: string;
  particleCount?: number;
}

const { color = '#1e3a8a', particleCount = 80 } = Astro.props;
---

<div class="pixel-blast-container" data-color={color} data-count={particleCount}>
  <canvas id="pixel-blast-canvas"></canvas>
</div>

<style>
  .pixel-blast-container {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
  }

  #pixel-blast-canvas {
    width: 100%;
    height: 100%;
  }
</style>

<script>
  const container = document.querySelector('.pixel-blast-container') as HTMLElement;
  const canvas = document.getElementById('pixel-blast-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  const baseColor = container?.dataset.color || '#1e3a8a';
  const particleCount = parseInt(container?.dataset.count || '80');

  let width = window.innerWidth;
  let height = window.innerHeight;
  let particles: Particle[] = [];
  let mouseX = width / 2;
  let mouseY = height / 2;
  let animationId: number;

  // Convert hex to RGB
  function hexToRgb(hex: string) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 30, g: 58, b: 138 };
  }

  const rgb = hexToRgb(baseColor);

  class Particle {
    x: number;
    y: number;
    size: number;
    baseSize: number;
    speedX: number;
    speedY: number;
    opacity: number;
    hue: number;
    pulse: number;
    pulseSpeed: number;

    constructor() {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.baseSize = Math.random() * 3 + 1;
      this.size = this.baseSize;
      this.speedX = (Math.random() - 0.5) * 0.5;
      this.speedY = (Math.random() - 0.5) * 0.5;
      this.opacity = Math.random() * 0.5 + 0.2;
      this.hue = Math.random() * 40 - 20; // Variation in hue
      this.pulse = Math.random() * Math.PI * 2;
      this.pulseSpeed = Math.random() * 0.02 + 0.01;
    }

    update() {
      // Floating movement
      this.x += this.speedX;
      this.y += this.speedY;

      // Pulse effect
      this.pulse += this.pulseSpeed;
      this.size = this.baseSize + Math.sin(this.pulse) * 0.5;

      // Mouse interaction - subtle attraction
      const dx = mouseX - this.x;
      const dy = mouseY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < 200) {
        const force = (200 - dist) / 200 * 0.01;
        this.x += dx * force;
        this.y += dy * force;
      }

      // Wrap around edges
      if (this.x < -10) this.x = width + 10;
      if (this.x > width + 10) this.x = -10;
      if (this.y < -10) this.y = height + 10;
      if (this.y > height + 10) this.y = -10;
    }

    draw() {
      const r = Math.min(255, Math.max(0, rgb.r + this.hue));
      const g = Math.min(255, Math.max(0, rgb.g + this.hue));
      const b = Math.min(255, Math.max(0, rgb.b + this.hue * 2));

      // Glow effect
      const gradient = ctx.createRadialGradient(
        this.x, this.y, 0,
        this.x, this.y, this.size * 4
      );
      gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${this.opacity})`);
      gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${this.opacity * 0.3})`);
      gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();

      // Core pixel
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${r + 50}, ${g + 50}, ${b + 100}, ${this.opacity + 0.3})`;
      ctx.fill();
    }
  }

  function init() {
    canvas.width = width;
    canvas.height = height;
    particles = [];

    for (let i = 0; i < particleCount; i++) {
      particles.push(new Particle());
    }
  }

  function drawConnections() {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 120) {
          const opacity = (1 - dist / 120) * 0.15;
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.strokeStyle = `rgba(${rgb.r + 30}, ${rgb.g + 30}, ${rgb.b + 60}, ${opacity})`;
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    }
  }

  function animate() {
    ctx.clearRect(0, 0, width, height);

    drawConnections();

    particles.forEach(particle => {
      particle.update();
      particle.draw();
    });

    animationId = requestAnimationFrame(animate);
  }

  function handleResize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }

  function handleMouseMove(e: MouseEvent) {
    mouseX = e.clientX;
    mouseY = e.clientY;
  }

  // Respect reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  if (!prefersReducedMotion) {
    init();
    animate();
    window.addEventListener('resize', handleResize);
    window.addEventListener('mousemove', handleMouseMove);
  } else {
    // Static version for reduced motion
    init();
    drawConnections();
    particles.forEach(p => p.draw());
  }
</script>
