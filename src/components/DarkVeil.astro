---
interface Props {
  hueShift?: number;
  noiseIntensity?: number;
  warpAmount?: number;
  scanlineIntensity?: number;
  speed?: number;
  baseColor?: string;
}

const {
  hueShift = 220, // Deep blue hue
  noiseIntensity = 0.15,
  warpAmount = 0.02,
  scanlineIntensity = 0.08,
  speed = 0.5,
  baseColor = '#0a1628'
} = Astro.props;
---

<div
  class="dark-veil-container"
  data-hue={hueShift}
  data-noise={noiseIntensity}
  data-warp={warpAmount}
  data-scanline={scanlineIntensity}
  data-speed={speed}
  data-color={baseColor}
>
  <canvas id="dark-veil-canvas"></canvas>
</div>

<style>
  .dark-veil-container {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    z-index: 0;
  }

  #dark-veil-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  const container = document.querySelector('.dark-veil-container') as HTMLElement;
  const canvas = document.getElementById('dark-veil-canvas') as HTMLCanvasElement;

  if (canvas && container) {
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') as WebGLRenderingContext;

    if (gl) {
      // Get parameters
      const hueShift = parseFloat(container.dataset.hue || '220');
      const noiseIntensity = parseFloat(container.dataset.noise || '0.15');
      const warpAmount = parseFloat(container.dataset.warp || '0.02');
      const scanlineIntensity = parseFloat(container.dataset.scanline || '0.08');
      const speed = parseFloat(container.dataset.speed || '0.5');

      // Vertex shader
      const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
          v_uv = a_position * 0.5 + 0.5;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Fragment shader - Dark Veil effect
      const fragmentShaderSource = `
        precision mediump float;

        varying vec2 v_uv;
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_hueShift;
        uniform float u_noiseIntensity;
        uniform float u_warpAmount;
        uniform float u_scanlineIntensity;

        // Noise functions
        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 st) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < 5; i++) {
            value += amplitude * noise(st);
            st *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        // HSV to RGB conversion
        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
          vec2 uv = v_uv;
          vec2 resolution = u_resolution;
          float time = u_time;

          // Warp distortion
          float warpX = fbm(uv * 3.0 + time * 0.1) * u_warpAmount;
          float warpY = fbm(uv * 3.0 + time * 0.15 + 100.0) * u_warpAmount;
          uv += vec2(warpX, warpY);

          // Base gradient - deep blue atmosphere
          float gradient = 1.0 - length(uv - 0.5) * 0.8;
          gradient = smoothstep(0.0, 1.0, gradient);

          // Flowing nebula effect
          float n1 = fbm(uv * 2.0 + time * 0.05);
          float n2 = fbm(uv * 3.0 - time * 0.08 + 50.0);
          float n3 = fbm(uv * 4.0 + time * 0.03 + 100.0);

          float nebula = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;

          // Color based on hue shift (deep blue range)
          float hue = u_hueShift / 360.0;
          float hueVariation = nebula * 0.08;

          vec3 color1 = hsv2rgb(vec3(hue - 0.02 + hueVariation, 0.7, 0.15));
          vec3 color2 = hsv2rgb(vec3(hue + hueVariation, 0.8, 0.25));
          vec3 color3 = hsv2rgb(vec3(hue + 0.05 + hueVariation, 0.6, 0.08));

          // Mix colors based on noise
          vec3 color = mix(color3, color1, nebula);
          color = mix(color, color2, n2 * gradient * 0.6);

          // Add subtle glow spots
          float glow1 = smoothstep(0.6, 0.0, length(uv - vec2(0.3 + sin(time * 0.2) * 0.1, 0.4)));
          float glow2 = smoothstep(0.5, 0.0, length(uv - vec2(0.7 + cos(time * 0.15) * 0.1, 0.6)));

          color += hsv2rgb(vec3(hue + 0.02, 0.5, 0.15)) * glow1 * 0.3;
          color += hsv2rgb(vec3(hue - 0.02, 0.6, 0.12)) * glow2 * 0.25;

          // Noise grain
          float grain = random(uv * resolution + time * 100.0) * u_noiseIntensity;
          color += grain * 0.5 - u_noiseIntensity * 0.25;

          // Scanlines
          float scanline = sin(uv.y * resolution.y * 0.5) * 0.5 + 0.5;
          scanline = pow(scanline, 2.0);
          color -= scanline * u_scanlineIntensity;

          // Vignette
          float vignette = 1.0 - length(uv - 0.5) * 0.7;
          vignette = smoothstep(0.0, 1.0, vignette);
          color *= vignette;

          // Final adjustments
          color = clamp(color, 0.0, 1.0);

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      // Compile shader
      function compileShader(source: string, type: number): WebGLShader | null {
        const shader = gl.createShader(type);
        if (!shader) return null;
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // Create program
      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

      if (vertexShader && fragmentShader) {
        const program = gl.createProgram();
        if (program) {
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);

          if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
            gl.useProgram(program);

            // Create geometry
            const positions = new Float32Array([
              -1, -1,
               1, -1,
              -1,  1,
               1,  1,
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Get uniform locations
            const timeLocation = gl.getUniformLocation(program, 'u_time');
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            const hueShiftLocation = gl.getUniformLocation(program, 'u_hueShift');
            const noiseIntensityLocation = gl.getUniformLocation(program, 'u_noiseIntensity');
            const warpAmountLocation = gl.getUniformLocation(program, 'u_warpAmount');
            const scanlineIntensityLocation = gl.getUniformLocation(program, 'u_scanlineIntensity');

            // Set static uniforms
            gl.uniform1f(hueShiftLocation, hueShift);
            gl.uniform1f(noiseIntensityLocation, noiseIntensity);
            gl.uniform1f(warpAmountLocation, warpAmount);
            gl.uniform1f(scanlineIntensityLocation, scanlineIntensity);

            let startTime = Date.now();
            let animationId: number;

            function resize() {
              const dpr = Math.min(window.devicePixelRatio, 2);
              canvas.width = canvas.clientWidth * dpr;
              canvas.height = canvas.clientHeight * dpr;
              gl.viewport(0, 0, canvas.width, canvas.height);
              gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            }

            function render() {
              const elapsed = (Date.now() - startTime) / 1000 * speed;
              gl.uniform1f(timeLocation, elapsed);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              animationId = requestAnimationFrame(render);
            }

            // Check for reduced motion preference
            const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            resize();
            window.addEventListener('resize', resize);

            if (!prefersReducedMotion) {
              render();
            } else {
              // Render single frame for reduced motion
              gl.uniform1f(timeLocation, 0);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
          }
        }
      }
    } else {
      // Fallback for no WebGL - use CSS gradient
      canvas.style.display = 'none';
      container.style.background = `
        radial-gradient(ellipse at 30% 40%, rgba(30, 64, 175, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 60%, rgba(59, 130, 246, 0.3) 0%, transparent 40%),
        linear-gradient(to bottom, #030712 0%, #0a1628 50%, #030712 100%)
      `;
    }
  }
</script>
